<!--
@author Vlad Bogdan Manica
-->
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx" 
		  xmlns:ns="org.flowerplatform.flexutil.view_content_host.*"		
		  creationComplete="creationCompleteHandler(event)"
		  implements="org.flowerplatform.flexutil.view_content_host.IViewContent" xmlns:ns1="org.flowerplatform.flex_client.resources.*">
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.collections.IList;
			import mx.events.FlexEvent;
			
			import spark.components.gridClasses.GridColumn;
			import spark.events.GridSelectionEvent;
			
			import org.flowerplatform.flex_client.core.CorePlugin;
			import org.flowerplatform.flex_client.core.editor.remote.Node;
			import org.flowerplatform.flex_client.resources.Resources;
			import org.flowerplatform.flex_client.team.git.GitConstants;
			import org.flowerplatform.flex_client.team.git.GitHistoryConstants;
			import org.flowerplatform.flex_client.team.git.action.CherryPickAction;
			import org.flowerplatform.flex_client.team.git.action.CreateBranchAction;
			import org.flowerplatform.flex_client.team.git.action.MergeAction;
			import org.flowerplatform.flex_client.team.git.action.history.action.CopyIdToClipboard;
			import org.flowerplatform.flexutil.FlexUtilGlobals;
			import org.flowerplatform.flexutil.Utils;
			import org.flowerplatform.flexutil.action.IAction;
			import org.flowerplatform.flexutil.context_menu.FillContextMenuEvent;
			import org.flowerplatform.flexutil.layout.event.ViewRemovedEvent;
			import org.flowerplatform.flexutil.selection.ISelectionProvider;
			import org.flowerplatform.flexutil.selection.SelectionChangedEvent;
			import org.flowerplatform.flexutil.view_content_host.IViewHost;
						
			[Bindable]
			public var repo:String;
			
			[Bindable]
			public var historyData:ArrayCollection;
			
			[Bindable]
			public var commitedFiles:ArrayCollection;
			
			[Bindable]
			public var files:ArrayCollection = new ArrayCollection;
			
			[Bindable]
			public var branchNames:ArrayCollection = new ArrayCollection;
			
			[Bindable] 
			public var content:String = new String;
			
			protected var _viewHost:IViewHost;
			
			[Bindable]
			public var maxGraphWidth:Number = new Number();
			
			public function creationCompleteHandler(flexvent:FlexEvent):void{
	
				Utils.makePseudoDisabled(infoRepo);
				
				var activeSelectionProvider:ISelectionProvider = FlexUtilGlobals.getInstance().selectionManager.activeSelectionProvider;
				if (activeSelectionProvider != null) {
					// create dummy event
					var event:SelectionChangedEvent = new SelectionChangedEvent();
					event.selection = activeSelectionProvider.getSelection();
					selectionChangedHandler(event);
				}
				// listen for selection changes				
				IEventDispatcher( _viewHost).addEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);
				FlexUtilGlobals.getInstance().selectionManager.addEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);							
			
				grid.addEventListener(FillContextMenuEvent.FILL_CONTEXT_MENU,fillContextMenuHandler);
			}
			
			public function fillContextMenuHandler(event:FillContextMenuEvent):void {
				event.allActions = getActions(new ArrayCollection([grid.selectedItem]));
				event.selection = new ArrayCollection([grid.selectedItem]);
				event.rootActionsAlreadyCalculated = null;
			}
			
			private function selectionChangedHandler(event:SelectionChangedEvent):void {
				var i:int;
				if (event.selection == null || event.selection.length == 0 || !(event.selection.getItemAt(0) is Node)) { 
					// happens when changing active view
					return;
				}		
				var node:Node = Node(event.selection.getItemAt(0));
				var index:int = node.nodeUri.indexOf("|");
				if (index < 0) {
					index = node.nodeUri.length;
				}
				repo = node.nodeUri.substring(node.nodeUri.indexOf(":") + 1, index);
				if (CorePlugin.getInstance().nodeTypeDescriptorRegistry.getOrCreateTypeDescriptor(node.type)
					.categories.getItemIndex(GitConstants.GIT_CATEGORY) >= 0) {
					initView(node, event);			
				}				
			}
			
			private function initView(node:Node, event:SelectionChangedEvent): void {
				infoRepo.text = "Repository: " + repo;
				CorePlugin.getInstance().serviceLocator.invoke("HistoryService.getLogEntries", [node.nodeUri],
					function(data:ArrayCollection):void {
						historyData = data; 
						findGraphWidth(data); 
						grid.selectedItem = historyData.getItemAt(0); 
						grid.ensureCellIsVisible(grid.selectedIndex);
						updateWindows(null);
					});
			}
			
			private function viewRemovedHandler(event:ViewRemovedEvent):void {
				FlexUtilGlobals.getInstance().selectionManager.removeEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);
			}
			
			public function additionalCloseHandler():void {
				// TODO Auto Generated method stub				
			}
			
			private function findGraphWidth(array:ArrayCollection):void {
				var maxValue:Number = 0;
				var mynode:Object; 
				
				for each(mynode in array) {					
					var drawingNode:Node = Node(Node(mynode).getPropertyValue(GitHistoryConstants.DRAWINGS));
					for each (var key:ArrayCollection in drawingNode.properties) {
						if (key.getItemAt(0) == GitHistoryConstants.DRAW_LINE) {
							
							var lines:Number = key.length;
							
							for (var i:Number = 1; i < lines; i += 7) {																
								if (maxValue < int(key.getItemAt(i+2))) {
									maxValue = int(key.getItemAt(i+2));								
								}								
							}											
						} 
						else if ( key.getItemAt(0) == GitHistoryConstants.DRAW_DOT) {
							if (maxValue < int(key.getItemAt(1))) {
								maxValue = int(key.getItemAt(1));								
							}							
						}							
					}	
				}		
				maxGraphWidth = maxValue+10;				
			}
			
			public function get viewHost():IViewHost {
				return _viewHost;
			}
			
			public function set viewHost(value:IViewHost):void {
				_viewHost = value;
			}
			
			public function getActions(selection:IList):Vector.<IAction> {
				var result:Vector.<IAction> = new Vector.<IAction>();
				result.push(new CopyIdToClipboard());
				result.push(new MergeAction(true));
				result.push(new CreateBranchAction(true));
				result.push(new CherryPickAction());
				return result;
			}
		
			public function getId(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.ID);
			}	
			
			public function getEntryShortId(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.ENTRY_SHORT_ID);
			}
			
			public function getShortMessage(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.SHORT_MESSAGE);
			}
			
			public function getAuthor(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.AUTHOR);
			}
			
			public function getAuthoredDate(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.AUTHORED_DATE);
			}
			
			public function getCommiter(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.COMMITTER);
			}
			
			public function getCommiterDate(obj:Object):String {
				return Node(obj).getPropertyValue(GitHistoryConstants.COMMITER_DATE);
			}		
			
			private function labelFunction(item:Object, column:GridColumn):String {
				if (column.dataField == GitHistoryConstants.ID) {	
					return 	getId(item);
				} else if (column.dataField == GitHistoryConstants.ENTRY_SHORT_ID) { 
					return getEntryShortId(item);
				}
				else if (column.dataField == GitHistoryConstants.SHORT_MESSAGE) { 
					return getShortMessage(item);
				}
				else if (column.dataField == GitHistoryConstants.AUTHOR) { 
					return getAuthor(item);
				}
				else if (column.dataField == GitHistoryConstants.AUTHORED_DATE) { 
					return formatDateTime.format(getAuthoredDate(item));
				}
				else if (column.dataField == GitHistoryConstants.COMMITTER) {
					return getCommiter(item);
				}
				else if (column.dataField == GitHistoryConstants.COMMITER_DATE) { 
					return  formatDateTime.format(getCommiterDate(item));
				}			
				return null;
			}
		
			private function updateWindows(event:GridSelectionEvent):void {
				CorePlugin.getInstance().serviceLocator.invoke("HistoryService.getCommitBranches", [Node(grid.selectedItem).nodeUri, String(Node(grid.selectedItem).getPropertyValue(GitHistoryConstants.ID))],function(data:ArrayCollection):void {branchNames = data; textAreaHandler(event);})
				CorePlugin.getInstance().serviceLocator.invoke("HistoryService.getCommitedData", [Node(grid.selectedItem).nodeUri, String(Node(grid.selectedItem).getPropertyValue(GitHistoryConstants.ID))],function(data2:ArrayCollection):void {commitedFiles = data2; listHandler(event);})
			}		
			
			public function handleLink(evt:TextEvent):void {
				var n:Number = historyData.length;
				for (var i:Number = 0; i < n; i++) {
					if ( String(Node(historyData.getItemAt(i)).getPropertyValue(GitHistoryConstants.ID)) == evt.text) {
						grid.selectedItem = Node(historyData.getItemAt(i));
						updateWindows(null);
						grid.ensureCellIsVisible(grid.selectedIndex);
						break;
					}
				}
			}
			
			public function linkFormat(commitId:String):String {
				return "<u><font color='#0000FF'><a href='event:"+commitId+"'>"+commitId+"</a></font></u>";
			}				
					
			private function textAreaHandler(event:GridSelectionEvent):void {				
				content = Resources.getMessage("flex_client.team.git.action.history.ui.history1",[
					Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.ID),
					Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.AUTHOR),
					Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.AUTHOR_EMAIL),					
					formatDateTime.format(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.AUTHORED_DATE)),
					Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.COMMITTER),
					Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.COMMITTER_EMAIL),
					formatDateTime.format(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.COMMITER_DATE))					
					]);
				
				var parentsLen:Number = ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.PARENT)).length;
				
				for (var i:Number = 0; i < parentsLen; i+=2) {
					content += Resources.getMessage("flex_client.team.git.action.history.ui.history2", [
							linkFormat(String(ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.PARENT)).getItemAt(i))),
							ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.PARENT)).getItemAt(i+1)
						]);					
				}
				var childsLen:Number = ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.CHILD)).length;
				for (i = 0; i < childsLen; i+=2) {
					content += Resources.getMessage("flex_client.team.git.action.history.ui.history3", [
						linkFormat(String(ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.CHILD)).getItemAt(i))),
						ArrayCollection(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.CHILD)).getItemAt(i+1)
					]);	
				}
				var  branchesLen:Number = branchNames.length;
				
				content += "Branches:";
				for (i = 0; i < branchesLen-1; i++) {
					content += branchNames.getItemAt(i)+", ";	
				}
				content += branchNames.getItemAt(branchesLen-1);

				content += "\n<b>"+String(Node(Node(grid.selectedItem)).getPropertyValue(GitHistoryConstants.LONG_MESSAGE))+"</b>";
	
				myTextArea.addEventListener(TextEvent.LINK,handleLink);
			}	
			
			private function listHandler(event:GridSelectionEvent):void {				
				files.removeAll();
 				for (var i:Number = 0; i < commitedFiles.length; i++) {
					files.addItemAt(Node(commitedFiles.getItemAt(i)).getPropertyValue(GitHistoryConstants.FILE), i);
				}							
			}			
			
			private function refreshHandler():void {
				creationCompleteHandler(null);			
			}
			
			private function commentsHandler(event:MouseEvent):void {				
				if (event.target.selected == true) {
					myTextArea.includeInLayout = true;
					myTextArea.visible = true;
					myHGroup.includeInLayout = true;
				}
				else {
					myTextArea.includeInLayout = false;
					myTextArea.visible = false;
					if (filesButton.selected == false) {
						myHGroup.includeInLayout = false;
					}
				}		
			}
			
			private function filesButtonHandler(event:MouseEvent):void {				
				if (event.target.selected == true) {
					myList.includeInLayout = true;
					myList.visible = true;
					myHGroup.includeInLayout = true;
				}
				else {
					myList.includeInLayout = false;
					myList.visible = false;
					if (commentsButton.selected == false) {
						myHGroup.includeInLayout = false;
					}
				}		
			}
		]]>
	</fx:Script>
	
	<s:HGroup width="100%">
		<s:TextInput id="infoRepo" contentBackgroundColor="0xE1E6E8" width="100%" height="25"/>	
		<s:Button icon="{Resources.refreshIcon}" width="30" height="100%" click="refreshHandler()"/>
		<s:ToggleButton id="commentsButton" icon="{Resources.commentsIcon}" selected="true" width="30" height="100%" click="commentsHandler(event)"/>
		<s:ToggleButton id="filesButton" icon="{Resources.flatLayoutIcon}" selected="true" width="30" height="100%" click="filesButtonHandler(event)"/>
	</s:HGroup>
	
	<s:DataGrid id="grid" dataProvider="{historyData}" height="100%" width="100%" sortableColumns="false"
				selectionChange="updateWindows(event)">
		<s:columns> 
			<s:ArrayList>
				<s:GridColumn id="myRender" dataField="drawings" headerText=""
							  itemRenderer="org.flowerplatform.flex_client.team.git.HistoryDrawingBox"
							  width="{maxGraphWidth}"/>
				
				<s:GridColumn labelFunction="labelFunction" headerText="Id" dataField="ShortId" />				
				<s:GridColumn labelFunction="labelFunction" headerText="Message" dataField="shortMessage" />
				<s:GridColumn labelFunction="labelFunction" headerText="Author" dataField="Author" />
				<s:GridColumn labelFunction="labelFunction" headerText="Authored Date" dataField="AuthoredDate" />
				<s:GridColumn labelFunction="labelFunction" headerText="Committer" dataField="Committer" />
				<s:GridColumn labelFunction="labelFunction" headerText="Committed Date" dataField="CommitteredDate" />
				
			</s:ArrayList>
		</s:columns>
	</s:DataGrid>

	<!-- Am modificat din prop proiectului: Library Path -> Framework Linkage => Merged into code -->
	<s:HGroup id="myHGroup" width="100%" height="100%">
		<mx:TextArea id="myTextArea" width="100%" height="100%" editable="false" htmlText="{content}"/>
		<s:List id="myList"
				width="100%" height="100%" 
				dataProvider="{files}">
				<s:itemRenderer>
					<fx:Component>
						<s:ItemRenderer>
							<fx:Script>
								<![CDATA[
									import org.flowerplatform.flex_client.resources.Resources;
								]]>
							</fx:Script>
							<s:HGroup paddingLeft="2" paddingTop="4" paddingRight="2" paddingBottom="2">	
								<s:Image source="{Resources.fileIcon}"/>
								<s:Label text="{this.data}" />
							</s:HGroup>
						</s:ItemRenderer>
					</fx:Component>
				</s:itemRenderer>			
		</s:List>		
	</s:HGroup>	
		
	<fx:Declarations>
		<mx:DateFormatter id="formatDateTime" formatString="YYYY-DD-MM HH:NN:SS" />
	</fx:Declarations>		
	
</s:VGroup>
