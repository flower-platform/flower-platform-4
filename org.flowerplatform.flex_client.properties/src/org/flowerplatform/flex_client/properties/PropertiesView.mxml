<?xml version="1.0" encoding="utf-8"?>
<!-- 
	license-start
 
	Copyright (C) 2008 - 2013 Crispico Software, <http://www.crispico.com/>.
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation version 3.
	 
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
	
	license-end
-->
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009"
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 creationComplete="creationCompleteHandler(event)"
		 implements="org.flowerplatform.flexutil.view_content_host.IViewContent, mx.managers.IFocusManagerComponent" gap="0">
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayList;
			import mx.collections.IList;
			import mx.core.IDataRenderer;
			import mx.core.IVisualElement;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			
			import org.flowerplatform.flex_client.core.CorePlugin;
			import org.flowerplatform.flex_client.core.editor.remote.Node;
			import org.flowerplatform.flex_client.core.node.controller.GenericValueProviderFromDescriptor;
			import org.flowerplatform.flex_client.core.node.controller.NodeControllerUtils;
			import org.flowerplatform.flex_client.core.node.event.NodeUpdatedEvent;
			import org.flowerplatform.flex_client.properties.property_line_renderer.IPropertyLineRenderer;
			import org.flowerplatform.flex_client.properties.property_line_renderer.PropertyLineRenderer;
			import org.flowerplatform.flex_client.properties.remote.PropertyDescriptor;
			import org.flowerplatform.flex_client.resources.Resources;
			import org.flowerplatform.flexutil.FlexUtilGlobals;
			import org.flowerplatform.flexutil.action.ActionBase;
			import org.flowerplatform.flexutil.action.IAction;
			import org.flowerplatform.flexutil.layout.event.ViewRemovedEvent;
			import org.flowerplatform.flexutil.selection.ISelectionProvider;
			import org.flowerplatform.flexutil.selection.SelectionChangedEvent;
			import org.flowerplatform.flexutil.view_content_host.IViewHost;
			
			protected var _viewHost:IViewHost;
								
			protected var showRawProperties:Boolean = true;
			
			protected function creationCompleteHandler(flexvent:FlexEvent):void {
				// get selection from active provider to populate properties list with data
				var activeSelectionProvider:ISelectionProvider = FlexUtilGlobals.getInstance().selectionManager.activeSelectionProvider;
				if (activeSelectionProvider != null) {
					// create dummy event
					var event:SelectionChangedEvent = new SelectionChangedEvent();
					event.selection = activeSelectionProvider.getSelection();
					
					selectionChangedHandler(event);
				}
				// listen for selection changes
				FlexUtilGlobals.getInstance().selectionManager.addEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);
				IEventDispatcher( _viewHost).addEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);
			}
			
			private function viewRemovedHandler(event:ViewRemovedEvent):void {
				FlexUtilGlobals.getInstance().selectionManager.removeEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);
			}
						
			public function get viewHost():IViewHost {
				return _viewHost;
			}
			
			public function set viewHost(value:IViewHost):void {
				_viewHost = value;
			}
			
			public function getActions(selection:IList):Vector.<IAction> {				
				return null;
			}
					
			public function additionalCloseHandler():void {	
				// nothing to do
			}
			
			private function selectionChangedHandler(event:SelectionChangedEvent):void {
				var i:int;
				
				// remove listeners from previous selection				
				if (PropertiesPlugin.getInstance().currentSelectedNode != null) {
					PropertiesPlugin.getInstance().currentSelectedNode.removeEventListener(NodeUpdatedEvent.NODE_UPDATED, nodeUpdatedHandler);
					PropertiesPlugin.getInstance().currentSelectedNode = null;
				}
								
				label.text = "";
								
				if (event.selection == null || event.selection.length == 0 || !(event.selection.getItemAt(0) is Node)) { // happens when changing active view						
					propertyForm.removeAllElements();
					return;
				}
				
				// get new selected node
				var node:Node = Node(event.selection.getItemAt(0));
				
				if (node.parent == null && node.children == null) { // root node, don't populate with properties					
					propertyForm.removeAllElements();
					return;					
				}
				
				// update label
				var titleProvider:GenericValueProviderFromDescriptor = NodeControllerUtils.getTitleProvider(CorePlugin.getInstance().nodeTypeDescriptorRegistry, node);
				label.text = String(titleProvider.getValue(node));
				label.maxWidth = UIComponent(this).width;
								
				// store new selection				
				PropertiesPlugin.getInstance().currentSelectedNode = node;
				
				refreshRenderers(node, showRawProperties);
														
				// add listeners to current selection				
				if (PropertiesPlugin.getInstance().currentSelectedNode != null) {					
					PropertiesPlugin.getInstance().currentSelectedNode.addEventListener(NodeUpdatedEvent.NODE_UPDATED, nodeUpdatedHandler);					
				}
			}
			
			private function nodeUpdatedHandler(event:NodeUpdatedEvent):void {
				var node:Node = event.node;
				
				for (var i:int = 0; i < propertyForm.numElements; i++) {
					var obj:Object = propertyForm.getElementAt(i);
					if (!(obj is PropertyLineRenderer)) {
						continue;
					}
					var propertyItemRenderer:PropertyLineRenderer = PropertyLineRenderer(obj);
					if (node.properties == null || !NodeControllerUtils.hasPropertyChanged(node, propertyItemRenderer.propertyDescriptor.name, event)) {
						continue;
					}
					propertyItemRenderer.node = node;																		
				}
			}		
					
			protected function getPropertiesToDisplay(node:Node, includeRawProperties:Boolean = false):Array {
				var properties:Array = new Array();
				var categories:Dictionary = new Dictionary();
				var propertyDescriptor:PropertyDescriptor;
				
				for (var key:* in node.properties) {
					propertyDescriptor = PropertiesPlugin.getInstance().getPropertyDescriptor(node, key, includeRawProperties);
					if (propertyDescriptor == null) { 
						// if no property descriptor found -> don't display it
						continue;
					}
					
					// verify if there is already created a dummy property descriptor for this category
					if (categories.hasOwnProperty(propertyDescriptor.category)) {
						// added -> make sure that it has the lowest index 
						categories[propertyDescriptor.category].orderIndex = Math.min(categories[propertyDescriptor.category].orderIndex, propertyDescriptor.orderIndex - 1);
					} else {
						// new category -> create a dummy property descriptor for it
						var dummyPropertyDescriptor:PropertyDescriptor = new PropertyDescriptor();						
						dummyPropertyDescriptor.propertyLineRenderer = PropertiesConstants.PROPERTY_LINE_RENDERER_TYPE_CATEGORY;
						dummyPropertyDescriptor.name = propertyDescriptor.category;
						// category must be displayed first, so it must have the lowest index
						dummyPropertyDescriptor.orderIndex = propertyDescriptor.orderIndex - 1; 
						
						categories[propertyDescriptor.category] = dummyPropertyDescriptor;
						properties.push(dummyPropertyDescriptor);
					}						
					properties.push(propertyDescriptor);
				}
				
				// sort property descriptors based on their orderIndex -> this will represent the display order for visual renderers
				properties.sort(function sortOnIndex(a:PropertyDescriptor, b:PropertyDescriptor):Number {				
					if (a.orderIndex > b.orderIndex) {
						return 1;
					} else if (a.orderIndex < b.orderIndex) {
						return -1;
					}
					return 0;
				});
				
				return properties;
			}
			
			protected function refreshRenderers(node:Node, includeRawProperties:Boolean = false):void {
				if (node == null) {
					return;
				}								
				var propertyDescriptor:PropertyDescriptor;				
				var properties:Array = getPropertiesToDisplay(node, includeRawProperties);
				
				var updatePropertyLineRendererData:Function = function(renderer:IPropertyLineRenderer, propertyDescriptor:PropertyDescriptor, node:Node):void {
					renderer.propertyDescriptor = propertyDescriptor;
					renderer.node = node;	
				};
				
				for (var i:int = 0; i < properties.length; i++) {
					var childRendererCandidate:IPropertyLineRenderer = null;
					propertyDescriptor = PropertyDescriptor(properties[i]);
										
					if (i < propertyForm.numElements) {
						// we still have renderer candidates
						childRendererCandidate = IPropertyLineRenderer(propertyForm.getElementAt(i)); 
						var childPropertyDescriptorCandidate:PropertyDescriptor = IPropertyLineRenderer(childRendererCandidate).propertyDescriptor;
						if (propertyDescriptor == childPropertyDescriptorCandidate) {
							updatePropertyLineRendererData(childRendererCandidate, propertyDescriptor, node);					
							// nothing to do, so skip							
							continue;
						} else {
							if (childPropertyDescriptorCandidate.type != propertyDescriptor.type || 
								childPropertyDescriptorCandidate.propertyLineRenderer != propertyDescriptor.propertyLineRenderer) {
								// the candidate renderer are not compatible => remove it
								propertyForm.removeElementAt(i);
								childRendererCandidate = null; // i.e. instruct the code below to create									
							} else {
								// a valid candidate								
							}
						}
					} 
					
					if (childRendererCandidate == null) {
						// i.e. either we have reached numElements,
						// or the candidate was not compatible/recyclable so it was removed					
						childRendererCandidate = PropertiesPlugin.getInstance().getNewPropertyLineRendererInstance(propertyDescriptor.propertyLineRenderer);	
						
						updatePropertyLineRendererData(childRendererCandidate, propertyDescriptor, node);	
						propertyForm.addElementAt(IVisualElement(childRendererCandidate), i);						
					} else {
						updatePropertyLineRendererData(childRendererCandidate, propertyDescriptor, node);					
					}					
				}
				
				// this loop happens if the number of models < number of renderers in the (probably recycled) parent renderer
				while (propertyForm.numElements > properties.length) {
					childRendererCandidate = IPropertyLineRenderer(propertyForm.getElementAt(propertyForm.numElements - 1));				
					propertyForm.removeElementAt(propertyForm.numElements - 1);					
				}
			}
			
		]]>
	</fx:Script>
	
	<s:HGroup width="100%" horizontalAlign="right" paddingLeft="5"  paddingRight="5" paddingBottom="5">
		<s:ToggleButton id="btnShowRawProps" 
						icon="{Resources.tableGear}" 
						toolTip="{Resources.getMessage('show.raw.properties')}"
						selected="{showRawProperties}"
						creationComplete="{if (!FlexUtilGlobals.getInstance().isMobile) {btnShowRawProps.width=22; btnShowRawProps.height=22;}}"
						click="{showRawProperties = !showRawProperties; refreshRenderers(PropertiesPlugin.getInstance().currentSelectedNode, showRawProperties);}" />
	</s:HGroup>

	<s:HGroup id="iconAndLabel" paddingLeft="5" paddingBottom="10" paddingRight="5">
		<s:Image id="icon" height="100%"/>
		<s:Label id="label" height ="100%" verticalAlign="middle"/>	
	</s:HGroup>
	
	<s:Scroller width="100%" height="100%">
		<s:Group width="100%" height="100%">			
			<s:Form id="propertyForm" width="100%" height="100%" >
			</s:Form>
		</s:Group>
	</s:Scroller>
</s:VGroup>

