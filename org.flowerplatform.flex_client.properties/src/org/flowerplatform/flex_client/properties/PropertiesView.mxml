<?xml version="1.0" encoding="utf-8"?>
<!-- 
	license-start
 
	Copyright (C) 2008 - 2013 Crispico Software, <http://www.crispico.com/>.
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation version 3.
	 
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
	
	license-end
-->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 creationComplete="creationCompleteHandler(event)"
		 implements="org.flowerplatform.flexutil.view_content_host.IViewContent, mx.managers.IFocusManagerComponent">
	<s:layout>
		<s:VerticalLayout gap="0"/>
	</s:layout>
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayList;
			import mx.collections.IList;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.utils.ObjectUtil;
			import mx.utils.StringUtil;
			
			import org.flowerplatform.flex_client.core.CoreConstants;
			import org.flowerplatform.flex_client.core.CorePlugin;
			import org.flowerplatform.flex_client.core.editor.remote.Node;
			import org.flowerplatform.flex_client.core.editor.update.event.NodeUpdatedEvent;
			import org.flowerplatform.flex_client.core.node.controller.GenericValueProviderFromDescriptor;
			import org.flowerplatform.flex_client.core.node.controller.NodeControllerUtils;
			import org.flowerplatform.flex_client.properties.property_renderer.BasicPropertyRenderer;
			import org.flowerplatform.flex_client.properties.property_renderer.CategoryPropertyRenderer;
			import org.flowerplatform.flex_client.properties.remote.PropertyDescriptor;
			import org.flowerplatform.flexutil.FlexUtilGlobals;
			import org.flowerplatform.flexutil.action.IAction;
			import org.flowerplatform.flexutil.layout.event.ViewRemovedEvent;
			import org.flowerplatform.flexutil.selection.ISelectionProvider;
			import org.flowerplatform.flexutil.selection.SelectionChangedEvent;
			import org.flowerplatform.flexutil.view_content_host.IViewHost;
			
			protected var _viewHost:IViewHost;
					
			private var currentPropertyDescriptorsDisplayed:IList;
			
			protected function creationCompleteHandler(flexvent:FlexEvent):void {
//				// get selection from active provider to populate properties list with data
				var activeSelectionProvider:ISelectionProvider = FlexUtilGlobals.getInstance().selectionManager.activeSelectionProvider;
				if (activeSelectionProvider != null) {
					// create dummy event
					var event:SelectionChangedEvent = new SelectionChangedEvent();
					event.selection = activeSelectionProvider.getSelection();
					
					selectionChangedHandler(event);
				}
//				// listen for selection changes
				FlexUtilGlobals.getInstance().selectionManager.addEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);
				IEventDispatcher( _viewHost).addEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);
			}
			
			private function viewRemovedHandler(event:ViewRemovedEvent):void {
				FlexUtilGlobals.getInstance().selectionManager.removeEventListener(SelectionChangedEvent.SELECTION_CHANGED, selectionChangedHandler);
			}
						
			public function get viewHost():IViewHost {
				return _viewHost;
			}
			
			public function set viewHost(value:IViewHost):void {
				_viewHost = value;
			}
			
			public function getActions(selection:IList):Vector.<IAction> {
				return null;
			}
						
			private function selectionChangedHandler(event:SelectionChangedEvent):void {
				var i:int;
				
				// remove listeners from previous selection
				var previousSelection:IList = PropertiesPlugin.getInstance().currentSelection;
				if (previousSelection != null) {
					for (i = 0; i < previousSelection.length; i++) {
						Node(previousSelection.getItemAt(i)).removeEventListener(NodeUpdatedEvent.NODE_UPDATED, nodeUpdatedHandler);
					}
				}
				
				// create a map with renderers that can be recicled (key -> renderer's type)
				var recycledRenderers:Dictionary = new Dictionary();
				for (i = 0; i < propertyForm.numElements; i++) {
					var obj:Object = propertyForm.getElementAt(i);
					if (!(obj is PropertyItemRenderer)) {
						continue;
					}
					var propertyItemRenderer:PropertyItemRenderer = PropertyItemRenderer(obj);
					var type:String = propertyItemRenderer.propertyDescriptor.type;
					if (!recycledRenderers[type]) {
						recycledRenderers[type] = [];
					}
					(recycledRenderers[type] as Array).push(propertyItemRenderer);
				}
								
				label.text = "";

				if (event.selection == null || event.selection.length == 0 || !(event.selection.getItemAt(0) is Node)) { // happens when changing active view	
					currentPropertyDescriptorsDisplayed = null;
					propertyForm.removeAllElements();
					return;
				}
				
				// get new selected node
				var node:Node = Node(event.selection.getItemAt(0));
				
				if (node.parent == null && node.children == null) { // root node, don't populate with properties
					currentPropertyDescriptorsDisplayed = null;
					propertyForm.removeAllElements();
					return;					
				}
				
				// update label
				var titleProvider:GenericValueProviderFromDescriptor = NodeControllerUtils.getTitleProvider(CorePlugin.getInstance().nodeTypeDescriptorRegistry, node);
				label.text = String(titleProvider.getValue(node));
				label.maxWidth = UIComponent(this).width;
								
				// store new selection				
				PropertiesPlugin.getInstance().currentSelection = new ArrayList(event.selection.toArray());
				
				// get properties to display
				var newPropertyDescriptorsToDisplay:IList = CorePlugin.getInstance().nodeTypeDescriptorRegistry.getExpectedTypeDescriptor(node.type).getAdditiveControllers(PropertiesConstants.PROPERTY_DESCRIPTOR, node);
			
				// if same descriptors -> no need to recalculate renderers, only set new node properties
				if (currentPropertyDescriptorsDisplayed != newPropertyDescriptorsToDisplay) {
					propertyForm.removeAllElements();
					
					// recalculate renderers
					var currentCategory:String = "";
					for (i = 0; i < newPropertyDescriptorsToDisplay.length; i++) {	
						var propertyRenderer:PropertyItemRenderer;
						var propertyDescriptor:PropertyDescriptor = PropertyDescriptor(ObjectUtil.copy(newPropertyDescriptorsToDisplay.getItemAt(i)));
											
						if (propertyDescriptor.category != currentCategory) {
							// display category renderer
							var categoryItem:CategoryPropertyRenderer = new CategoryPropertyRenderer();
							categoryItem.label = propertyDescriptor.category;
							propertyForm.addElement(categoryItem);
								
							currentCategory = propertyDescriptor.category;
						}
								
						var renderersToReuse:Array = recycledRenderers[propertyDescriptor.type] as Array;
						if (renderersToReuse != null && renderersToReuse.length > 0) {
							// there is already created a renderer for this type of property descriptor, reuse it
							propertyRenderer = PropertyItemRenderer(renderersToReuse.pop());
						} else { // new renderer 0> create it
							propertyRenderer = new PropertyItemRenderer();
							propertyRenderer.basicPropertyRendererType = propertyDescriptor.type;							
						}				
						propertyForm.addElement(propertyRenderer);
						propertyRenderer.data = propertyDescriptor;
					}
				}
				
				// cached property descriptors displayed
				currentPropertyDescriptorsDisplayed = newPropertyDescriptorsToDisplay;
				
				// get values from node properties
				nodeUpdatedHandler(new NodeUpdatedEvent(node));
										
				// add listeners to current selection
				var currentSelection:IList = PropertiesPlugin.getInstance().currentSelection;
				if (currentSelection != null) {
					for (i = 0; i < currentSelection.length; i++) {
						Node(currentSelection.getItemAt(i)).addEventListener(NodeUpdatedEvent.NODE_UPDATED, nodeUpdatedHandler);
					}
				}
			}
			
			private function nodeUpdatedHandler(event:NodeUpdatedEvent):void {
				var node:Node = event.node;
				
				for (var i:int = 0; i < propertyForm.numElements; i++) {
					var obj:Object = propertyForm.getElementAt(i);
					if (!(obj is PropertyItemRenderer)) {
						continue;
					}
					var propertyItemRenderer:PropertyItemRenderer = PropertyItemRenderer(obj);
					if (node.properties == null || !NodeControllerUtils.hasPropertyChanged(node, propertyItemRenderer.propertyDescriptor.name, event)) {
						continue;
					}
					var defaultPropertyName:String = StringUtil.substitute(CoreConstants.PROPERTY_DEFAULT_FORMAT, propertyItemRenderer.propertyDescriptor.name);
					if (node.properties.hasOwnProperty(defaultPropertyName)) {
						BasicPropertyRenderer(propertyItemRenderer.getElementAt(0)).defaultValue = node.properties[defaultPropertyName];
					}								
					PropertyDescriptor(propertyItemRenderer.data).value = node.properties[propertyItemRenderer.propertyDescriptor.name];															
				}
			}
			
		]]>
	</fx:Script>
	<s:HGroup id = "iconAndLabel" paddingLeft="5">
		<s:Image id="icon" height="100%"/>
		<s:Label id="label" height ="100%" verticalAlign="middle"/>	
	</s:HGroup>
	
	<s:Scroller width="100%" height="100%">
		<s:Group width="100%" height="100%">			
			<s:Form id="propertyForm" width="100%" height="100%" >
			</s:Form>
		</s:Group>
	</s:Scroller>
</s:Group>
